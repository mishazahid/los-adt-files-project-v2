#!/usr/bin/env python3
"""
Summary Combiner Script

This script combines all summarized CSV files (generated by csv_combiner.py) 
into a single master CSV file for cross-facility analysis.

The script finds all files matching patterns like:
- summarized_*.csv
- Summarized_Data.csv
- *_summarized.csv

And combines them into one comprehensive summary file.

Usage:
    python summary_combiner.py <input_folder> <output_file>
    python summary_combiner.py --input-folder summaries/ --output-file master_summary.csv
    python summary_combiner.py --input-folder summaries/ --output-file master_summary.csv --include-totals

Examples:
    # Combine all summarized files in a folder
    python summary_combiner.py output_folder/ master_summary.csv
    
    # Include totals row
    python summary_combiner.py output_folder/ master_summary.csv --include-totals
"""

import pandas as pd
import argparse
import sys
import os
from pathlib import Path
import glob
from typing import List, Dict


def find_summarized_files(input_folder: str) -> List[str]:
    """
    Find all summarized CSV files in the input folder.
    
    Args:
        input_folder: Path to folder containing summarized files
    
    Returns:
        List of file paths to summarized CSV files
    """
    folder = Path(input_folder)
    if not folder.exists():
        raise FileNotFoundError(f"Input folder not found: {input_folder}")
    
    # Define patterns to search for summarized files
    patterns = [
        "summarized_*.csv",
        "Summarized_*.csv", 
        "*_summarized.csv",
        "*_Summarized.csv",
        "Summarized_Data.csv"
    ]
    
    found_files = []
    
    for pattern in patterns:
        # Search in main directory
        search_pattern = folder / pattern
        found_files.extend(glob.glob(str(search_pattern), recursive=False))
        
        # Search in subdirectories
        search_pattern = folder / "**" / pattern
        found_files.extend(glob.glob(str(search_pattern), recursive=True))
    
    # Remove duplicates and sort
    found_files = sorted(list(set(found_files)))
    
    print(f"Found {len(found_files)} summarized files:")
    for file_path in found_files:
        print(f"  - {Path(file_path).name}")
    
    return found_files


def find_combined_files(input_folder: str) -> List[str]:
    """
    Find all combined CSV files in the input folder.
    
    Args:
        input_folder: Path to folder containing combined files
    
    Returns:
        List of file paths to combined CSV files
    """
    folder = Path(input_folder)
    if not folder.exists():
        raise FileNotFoundError(f"Input folder not found: {input_folder}")
    
    # Define patterns to search for combined files
    patterns = [
        "combined_*.csv",
        "Combined_*.csv"
    ]
    
    found_files = []
    
    for pattern in patterns:
        # Search in main directory
        search_pattern = folder / pattern
        found_files.extend(glob.glob(str(search_pattern), recursive=False))
        
        # Search in subdirectories
        search_pattern = folder / "**" / pattern
        found_files.extend(glob.glob(str(search_pattern), recursive=True))
    
    # Remove duplicates and sort
    found_files = sorted(list(set(found_files)))
    
    print(f"Found {len(found_files)} combined files:")
    for file_path in found_files:
        print(f"  - {Path(file_path).name}")
    
    return found_files


def extract_facility_name_from_combined_file(filename: str) -> str:
    """
    Extract facility name from combined CSV filename.
    
    Args:
        filename: The filename to extract facility name from
    
    Returns:
        Properly formatted facility name
    """
    name = Path(filename).stem.lower()
    
    # Remove "combined_" prefix
    if name.startswith('combined_'):
        name = name[9:]  # Remove "combined_"
    
    # Remove "of_" prefix if present (handles cases like "combined_of_mt._pleasant")
    if name.startswith('of_'):
        name = name[3:]  # Remove "of_"
    
    # Convert underscores to spaces and title case
    display_name = name.replace('_', ' ').title()
    
    # Handle specific facility name patterns
    if 'At The Shore' in display_name:
        return 'Medilodge at the Shore'
    elif 'Sterling Heights' in display_name:
        return 'Medilodge of Sterling Heights'
    elif 'Farmington' in display_name:
        return 'Medilodge of Farmington'
    elif 'Sault St Marie' in display_name:
        return 'Medilodge of Sault St. Marie'
    elif 'Clare' in display_name:
        return 'Medilodge of Clare'
    elif 'Ludington' in display_name:
        return 'Medilodge of Ludington'
    elif 'Mt. Pleasant' in display_name or 'Mt Pleasant' in display_name:
        return 'Medilodge of Mt. Pleasant'
    elif 'Holland' in display_name:
        return 'Medilodge of Holland'
    elif 'Wyoming' in display_name:
        return 'Medilodge of Wyoming'
    elif 'Grand Rapids' in display_name:
        return 'Medilodge of Grand Rapids'
    elif 'Grand Blanc' in display_name:
        return 'Medilodge of Grand Blanc'
    elif 'Monroe' in display_name:
        return 'Medilodge of Monroe'
    elif 'Howell' in display_name:
        return 'Medilodge of Howell'
    elif 'Montrose' in display_name:
        return 'Medilodge of Montrose'
    elif 'Shoreline' in display_name:
        return 'Medilodge of Shoreline'
    elif 'Autumn Woods' in display_name or 'Autumn' in display_name:
        # Non-Medilodge facility - return as-is without prefix
        formatted_name = display_name.title()
        formatted_name = formatted_name.replace('St ', 'St. ')
        formatted_name = formatted_name.replace('Mt ', 'Mt. ')
        return formatted_name
    else:
        # Default formatting for other facilities
        formatted_name = display_name.title()
        formatted_name = formatted_name.replace('St ', 'St. ')
        formatted_name = formatted_name.replace('Mt ', 'Mt. ')
        
        # Check if it's a non-Medilodge facility (e.g., "Autumn Woods Residential")
        # If the name doesn't contain "medilodge", return it as-is without prefix
        if 'medilodge' not in name:
            return formatted_name
        
        # Special case for "at the" facilities
        if 'At The' in formatted_name:
            return f'Medilodge at the {formatted_name.replace("At The ", "")}'
        
        return f'Medilodge of {formatted_name}'


def load_combined_file(file_path: str) -> pd.DataFrame:
    """
    Load a combined CSV file and add facility name column.
    
    Args:
        file_path: Path to the combined CSV file
    
    Returns:
        DataFrame containing the combined data with facility name
    """
    try:
        df = pd.read_csv(file_path)
        
        # Extract facility name from filename
        facility_name = extract_facility_name_from_combined_file(file_path)
        
        # Add facility name as the first column
        df.insert(0, 'Facility', facility_name)
        
        print(f"[OK] Loaded {Path(file_path).name}: {df.shape[0]} rows, {df.shape[1]} columns")
        print(f"  Facility: {facility_name}")
        return df
        
    except Exception as e:
        print(f"[FAILED] Error loading {Path(file_path).name}: {e}")
        return None


def combine_all_patient_data(file_paths: List[str]) -> pd.DataFrame:
    """
    Combine all combined files into a single DataFrame with all patient data.
    
    Args:
        file_paths: List of paths to combined CSV files
    
    Returns:
        Combined DataFrame with all patient data from all facilities
    """
    print(f"\n--- Loading and Combining Patient Data ---")
    
    combined_data = []
    successful_loads = 0
    
    for file_path in file_paths:
        df = load_combined_file(file_path)
        if df is not None:
            combined_data.append(df)
            successful_loads += 1
    
    if not combined_data:
        raise ValueError("No valid combined files could be loaded!")
    
    # Combine all DataFrames
    all_patients_df = pd.concat(combined_data, ignore_index=True)
    
    print(f"\n[OK] Successfully combined {successful_loads} files")
    print(f"  Total patients: {len(all_patients_df)}")
    print(f"  Total columns: {len(all_patients_df.columns)}")
    
    # Show facility breakdown
    if 'Facility' in all_patients_df.columns:
        facility_counts = all_patients_df['Facility'].value_counts()
        print(f"\nPatients by facility:")
        for facility, count in facility_counts.items():
            print(f"  {facility}: {count} patients")
    
    return all_patients_df


def load_summarized_file(file_path: str) -> pd.DataFrame:
    """
    Load a summarized CSV file and validate its structure.
    
    Args:
        file_path: Path to the summarized CSV file
    
    Returns:
        DataFrame containing the summarized data
    """
    try:
        df = pd.read_csv(file_path)
        
        # Check if it has the expected columns
        expected_columns = ['Facility', 'Patients Served', 'Total Visits']
        missing_columns = [col for col in expected_columns if col not in df.columns]
        
        if missing_columns:
            print(f"⚠️  Warning: {Path(file_path).name} is missing columns: {missing_columns}")
            print(f"   Available columns: {list(df.columns)}")
        
        print(f"[OK] Loaded {Path(file_path).name}: {df.shape[0]} rows, {df.shape[1]} columns")
        return df
        
    except Exception as e:
        print(f"[FAILED] Error loading {Path(file_path).name}: {e}")
        return None


def combine_summarized_files(file_paths: List[str]) -> pd.DataFrame:
    """
    Combine all summarized files into a single DataFrame.
    
    Args:
        file_paths: List of paths to summarized CSV files
    
    Returns:
        Combined DataFrame with all facility summaries
    """
    print(f"\n--- Loading and Combining Files ---")
    
    combined_data = []
    successful_loads = 0
    
    for file_path in file_paths:
        df = load_summarized_file(file_path)
        if df is not None:
            combined_data.append(df)
            successful_loads += 1
    
    if not combined_data:
        raise ValueError("No valid summarized files could be loaded!")
    
    # Combine all DataFrames
    master_df = pd.concat(combined_data, ignore_index=True)
    
    print(f"\n[OK] Successfully combined {successful_loads} files")
    print(f"  Total facilities: {len(master_df)}")
    print(f"  Total columns: {len(master_df.columns)}")
    
    return master_df


def add_totals_row(df: pd.DataFrame) -> pd.DataFrame:
    """
    Add a totals row to the DataFrame.
    
    Args:
        df: DataFrame to add totals to
    
    Returns:
        DataFrame with totals row added
    """
    print(f"\n--- Adding Totals Row ---")
    
    # Create a copy to avoid modifying the original
    df_with_totals = df.copy()
    
    # Calculate totals for numeric columns
    totals_row = {}
    
    for column in df.columns:
        if column == 'Facility':
            totals_row[column] = 'TOTAL'
        elif df[column].dtype in ['int64', 'float64']:
            # Sum numeric columns
            totals_row[column] = df[column].sum()
        else:
            # For non-numeric columns, use the first value or a placeholder
            totals_row[column] = df[column].iloc[0] if len(df) > 0 else ''
    
    # Add the totals row
    totals_df = pd.DataFrame([totals_row])
    df_with_totals = pd.concat([df_with_totals, totals_df], ignore_index=True)
    
    print(f"[OK] Added totals row")
    print(f"  Total Patients Served: {totals_row.get('Patients Served', 'N/A')}")
    print(f"  Total Visits: {totals_row.get('Total Visits', 'N/A')}")
    
    return df_with_totals


def calculate_additional_metrics(df: pd.DataFrame) -> pd.DataFrame:
    """
    Calculate additional metrics for the combined data.
    
    Args:
        df: Combined DataFrame
    
    Returns:
        DataFrame with additional calculated metrics
    """
    print(f"\n--- Calculating Additional Metrics ---")
    
    df_with_metrics = df.copy()
    
    # Calculate percentages if we have totals
    if 'Patients Served' in df.columns and 'Total Visits' in df.columns:
        df_with_metrics['Visits per Patient'] = (
            df_with_metrics['Total Visits'] / df_with_metrics['Patients Served']
        ).round(2)
    
    # Calculate facility rankings
    if 'Total Visits' in df.columns:
        df_with_metrics['Visit Ranking'] = df_with_metrics['Total Visits'].rank(ascending=False, method='min').astype(int)
    
    if 'Patients Served' in df.columns:
        df_with_metrics['Patient Ranking'] = df_with_metrics['Patients Served'].rank(ascending=False, method='min').astype(int)
    
    print(f"[OK] Added additional metrics:")
    print(f"  - Visits per Patient")
    print(f"  - Visit Ranking")
    print(f"  - Patient Ranking")
    
    return df_with_metrics


def save_master_summary(df: pd.DataFrame, output_file: str) -> None:
    """
    Save the master summary DataFrame to CSV.
    
    Args:
        df: Master summary DataFrame
        output_file: Path for the output CSV file
    """
    print(f"\n--- Saving Master Summary ---")
    
    try:
        # Create output directory if it doesn't exist
        output_dir = Path(output_file).parent
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Save to CSV
        df.to_csv(output_file, index=False)
        
        print(f"[OK] Master summary saved to: {output_file}")
        print(f"  Total facilities: {len(df)}")
        print(f"  Total columns: {len(df.columns)}")
        
        # Display summary statistics
        print(f"\n--- Summary Statistics ---")
        if 'Patients Served' in df.columns:
            total_patients = df['Patients Served'].sum()
            print(f"Total Patients Served: {total_patients}")
        
        if 'Total Visits' in df.columns:
            total_visits = df['Total Visits'].sum()
            print(f"Total Visits: {total_visits}")
        
        if 'Visits per Patient' in df.columns:
            avg_visits = df['Visits per Patient'].mean()
            print(f"Average Visits per Patient: {avg_visits:.2f}")
        
        # Show top facilities by visits
        if 'Total Visits' in df.columns and 'Facility' in df.columns:
            print(f"\nTop 3 Facilities by Visits:")
            top_facilities = df.nlargest(3, 'Total Visits')[['Facility', 'Total Visits']]
            for idx, row in top_facilities.iterrows():
                print(f"  {row['Facility']}: {row['Total Visits']} visits")
        
        print(f"\nFirst few rows:")
        print(df.head().to_string(index=False))
        
    except Exception as e:
        print(f"[FAILED] Error saving master summary: {e}")
        sys.exit(1)


def save_all_patients(df: pd.DataFrame, output_file: str) -> None:
    """
    Save the all patients DataFrame to CSV.
    
    Args:
        df: All patients DataFrame
        output_file: Path for the output CSV file
    """
    print(f"\n--- Saving All Patients Data ---")
    
    try:
        # Create output directory if it doesn't exist
        output_dir = Path(output_file).parent
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Save to CSV
        df.to_csv(output_file, index=False)
        
        print(f"[OK] All patients data saved to: {output_file}")
        print(f"  Total patients: {len(df)}")
        print(f"  Total columns: {len(df.columns)}")
        
        # Display summary statistics
        print(f"\n--- Patient Data Statistics ---")
        if 'Facility' in df.columns:
            facility_counts = df['Facility'].value_counts()
            print(f"Patients by facility:")
            for facility, count in facility_counts.items():
                print(f"  {facility}: {count} patients")
        
        if 'Puzzle Patient' in df.columns:
            puzzle_patients = df['Puzzle Patient'].sum()
            print(f"\nPuzzle patients: {puzzle_patients}/{len(df)} ({puzzle_patients/len(df)*100:.1f}%)")
        
        if 'Number of Visits by Puzzle Provider' in df.columns:
            total_visits = df['Number of Visits by Puzzle Provider'].sum()
            print(f"Total visits: {total_visits}")
        
        print(f"\nFirst few rows:")
        print(df.head().to_string(index=False))
        
    except Exception as e:
        print(f"[FAILED] Error saving all patients data: {e}")
        sys.exit(1)


def main():
    """Main function to orchestrate the summary combining process."""
    parser = argparse.ArgumentParser(
        description="Combine summarized CSV files into master summary and/or combine all patient data from combined files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Combine all summarized files in a folder
  python summary_combiner.py output_folder/ master_summary.csv
  
  # Include totals row
  python summary_combiner.py output_folder/ master_summary.csv --include-totals
  
  # Create all_patients file from combined files
  python summary_combiner.py --input-folder output_folder/ --all-patients all_patients.csv
  
  # Create both master summary and all_patients files
  python summary_combiner.py --input-folder output_folder/ --output-file master_summary.csv --all-patients all_patients.csv --include-totals
        """
    )
    
    # Add arguments
    parser.add_argument('input_folder', nargs='?', help='Path to folder containing summarized CSV files')
    parser.add_argument('output_file', nargs='?', help='Path for the output master summary CSV file')
    parser.add_argument('--input-folder', help='Path to folder containing summarized CSV files')
    parser.add_argument('--output-file', help='Path for the output master summary CSV file')
    parser.add_argument('--include-totals', action='store_true', help='Include a totals row in the output')
    parser.add_argument('--add-metrics', action='store_true', help='Add additional calculated metrics')
    parser.add_argument('--all-patients', help='Path for the output all patients CSV file (combines all combined_*.csv files)')
    
    args = parser.parse_args()
    
    # Determine input folder and output file
    input_folder = args.input_folder or args.input_folder
    output_file = args.output_file or args.output_file
    
    if not input_folder:
        parser.error("input_folder is required")
    
    if not output_file and not args.all_patients:
        parser.error("Either output_file or --all-patients (or both) must be specified")
    
    print("=" * 80)
    print("SUMMARY COMBINER")
    print("=" * 80)
    print(f"Input folder: {input_folder}")
    print(f"Output file: {output_file}")
    print(f"Include totals: {args.include_totals}")
    print(f"Add metrics: {args.add_metrics}")
    print(f"All patients file: {args.all_patients}")
    print("=" * 80)
    
    try:
        # Process summarized files if output file is specified
        if output_file:
            # Find all summarized files
            summarized_files = find_summarized_files(input_folder)
            
            if not summarized_files:
                print("[FAILED] No summarized files found!")
                sys.exit(1)
            
            # Combine all files
            master_df = combine_summarized_files(summarized_files)
            
            # Add additional metrics if requested
            if args.add_metrics:
                master_df = calculate_additional_metrics(master_df)
            
            # Add totals row if requested
            if args.include_totals:
                master_df = add_totals_row(master_df)
            
            # Save the master summary
            save_master_summary(master_df, output_file)
        
        # Process combined files for all_patients if specified
        if args.all_patients:
            # Find all combined files
            combined_files = find_combined_files(input_folder)
            
            if not combined_files:
                print("[FAILED] No combined files found!")
                sys.exit(1)
            
            # Combine all patient data
            all_patients_df = combine_all_patient_data(combined_files)
            
            # Save the all patients file
            save_all_patients(all_patients_df, args.all_patients)
        
        print("\n" + "=" * 80)
        print("[OK] SUMMARY COMBINING COMPLETE!")
        print("=" * 80)
        
    except Exception as e:
        print(f"[FAILED] Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()